package doharm.logic;

public class TODO {
	/**
	 * 
	 * picking up items
	 * attacking
	 * fix collision detection
	 * Basic AI character states
	 * distribute dragonballs
	 * monsters
	 * 
	 * 
	 * 
	 * 
	 * multiple spawn positions (need seperate file for world containing objects etc... x,y,layer)
	 * 
	 * 
	 * 
	 * factory method pattern - for creating players, items, etc.
	 * 
	 * Composite pattern - Hierarchy of entities that have different versions of the same method
	 * 
	 * Visitor pattern - Items that use an entity to perform an action.
	 * 		-Character has useItem(Item item); then item will have a method
	 * 
	 * Facade pattern - Game is the facade.
	 * 
	 * 
	 * Flyweight - use a singleton rather than many duplicate objects - Tile
	 * identify objects which are
		essentially identical (or refactor program
		to expose them); then, provide static
		factory methods for creating them which
		ensures only one instance for each
		distinct example.
	 * 
	 * 
	 * Observer? 
	 * 
	 * Strategy (5)
	 * 
	 * 	class Book{...
			LendingPolicy policy;
			int loanLength(Patron p){return policy.loanLength(p);}
		}
		interface LendingPolicy{
			int loanLength(Patron p);
		}
		
		
		State pattern - AIState, use a seperate class for each state, combination of strategy pattern.
	 *  
	 * 
	 * 
	 * 
	 * fall damage
	 * mining?
	 * 
	 * 
	 * 
	 * COMPOSITE
		VISITOR
		FACADE
		FLYWEIGHT
		OBSERVER
		STRATEGY
		NULL OBJECT
		STATE
		DECORATOR
		ADAPTER
	 */

}
